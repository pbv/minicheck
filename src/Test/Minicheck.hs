{-# LANGUAGE GeneralizedNewtypeDeriving  #-}

module Test.Minicheck where

import qualified System.Random as R
import           Data.Tree       --  multiway trees a.k.a. rose trees 
import           Control.Monad
import           Text.Printf

--
-- generators
--
newtype Gen a = MkGen { runGen :: R.StdGen -> a }
              deriving (Functor, Applicative)

-- | NB: this is not just the reader monad for (StdGen ->)
-- because the random generator is split between computations
instance Monad Gen where
  m >>= f = MkGen (\s -> let (s', s'') = R.split s
                         in runGen (f (runGen m s')) s'')

-- base generators
-- choose a discrete random value uniformly
choose :: R.Random a => (a, a) -> Gen a
choose (lo,hi) = MkGen (fst . R.randomR (lo,hi))

-- choose from a list
elements :: [a] -> Gen a
elements vs = do
  k <- choose (0, length vs-1)
  return (vs!!k)

-- choose a generator from a list 
oneof :: [Gen a] -> Gen a
oneof gs = do
  k <- choose (0, length gs-1)
  gs!!k


-- | sample a generator
sample :: Gen a -> IO a
sample gen = do
  (s,s') <- R.split <$> R.getStdGen
  R.setStdGen s'
  return (runGen gen s)

--
-- type class for generation & shrinking 
-- 
class Arbitrary a where
  arbitrary :: Gen a
  shrink :: a -> [a]
  shrink = const []


instance Arbitrary Int where
  arbitrary =  choose (minBound, maxBound)
  shrink  = shrinkIntegral 

instance Arbitrary Bool where
  arbitrary = elements [False,True]
  shrink False = []
  shrink True = [False]


shrinkIntegral :: Integral a => a -> [a]
shrinkIntegral n
  | n>0 = 0 : [n`div`2 | n>2] ++ [n-2 | n>2] ++ [n-1 | n>1]
  | n<0 = 0 : 1 : [n`div`2 | n<(-2)] ++ [n+2 | n<(-2)] ++ [n+1 | n<(-1)]
shrinkIntegral _ = []


  
instance (Arbitrary a, Arbitrary b) => Arbitrary (a,b) where
  arbitrary = (,) <$> arbitrary <*> arbitrary
  shrink (x,y) = [ (x',y) | x' <- shrink x ] ++
                 [ (x,y') | y' <- shrink y ] 

--
-- properties and testing
--
data Result
  = MkResult { ok :: Bool -- ^ True if test passed, False otherwise
             , testCase :: [String] -- ^ for reporting failed tests
             }
  deriving Show

-- | A property a generator for (lazy) trees of results
-- generated by applying the shrinking functions
--
newtype Prop = MkProp { unProp :: Gen (Tree Result) }

liftBool :: Bool -> Result
liftBool b = MkResult {ok=b, testCase=[]}

mapResult :: Testable prop => (Result -> Result) -> prop -> Prop
mapResult f = MkProp . fmap (fmap f). unProp . property 

-- | Adds the given string to the counterexample
counterexample :: Testable prop => String -> prop -> Prop
counterexample s = mapResult (\r -> r{ testCase = s:testCase r }) 

-- | a class for things can be tested,
-- i.e. transformed into a property
--
class Testable a where
  property :: a -> Prop

instance Testable Prop where
  property p = p

instance Testable Bool where
  property b =
    MkProp $ return $ Node { rootLabel = liftBool b, subForest=[] }

-- | for testing functions, we need an arbitrary instance
-- for the argument
instance (Arbitrary a, Show a, Testable b) => Testable (a -> b) where
  property pf = forAllShrink arbitrary shrink pf

-- | quantification given a generator and a shrinking function
forAllShrink :: (Show a, Testable prop) =>
                Gen a -> (a -> [a]) -> (a -> prop) -> Prop
forAllShrink gen shrinker pf = MkProp $ do
  a <- gen
  unProp $ shrinking shrinker a pf

-- | quantification with no shrinking
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Prop
forAll gen = forAllShrink gen (const []) 

-- | generate the shrinking tree for an argument to a property
-- first use `props' to build a       Tree (Gen (Tree Result))
-- then use `promote' to  get         Gen (Tree (Tree Result)
-- finally use `joinTree` to flatten  Gen (Tree Result) 
shrinking :: (Testable prop, Show a) => (a -> [a]) -> a -> (a -> prop) -> Prop
shrinking shrinker x0 pf 
  = MkProp $ fmap joinTree (promote (props x0))
 where
   props x = Node { rootLabel =
                      unProp $ property $ counterexample (show x) $ pf x
                  , subForest = [ props x' | x' <- shrinker x ]
                  }

-- helper functions taken from the QuickCheck source
-- pull out generator from a monadic computation
promote :: Monad m => m (Gen a) -> Gen (m a)
promote m = do
  eval <- delay
  return (liftM eval m)

-- generate running function for the Gen monad;
-- this duplicates the random generator and so is "unsafe"
delay :: Gen (Gen a -> a)
delay = MkGen (\s g -> runGen g s)

-- flatten a tree
joinTree :: Tree (Tree a) -> Tree a
joinTree (Node (Node x xs) xss) = Node x (map joinTree xss ++ xs)
 -- alternative: Node x (xs ++ map joinTree xss)
 -- but according to the QuickCheck devs this choice is better?



--
-- Testing parameters
--
maxTests, maxShrinks :: Int
maxTests = 1000
maxShrinks = 1000

-- | check a property and shrink to a minimal counterexample
--
check :: Testable prop => prop -> IO ()
check prop = checkWith failure prop
  where
    failure t@(Node r _) = do
      putStrLn "Failed test case:"
      printTestCase r
      putStrLn "Shrinking"
      r' <- shrinkSearch t
      putStrLn "Minimal test case:"
      printTestCase r'


-- | check a property and print the shrinking tree
checkTree :: Testable prop => prop -> IO ()
checkTree  = checkWith (putStr . drawTree . fmap show)

-- | test a property providing a callback for a failure 
checkWith :: Testable prop => (Tree Result -> IO ()) -> prop -> IO ()
checkWith callback prop  = putStr "Testing" >> loop 1
  where
    loop i | i<maxTests = do
               t@(Node r _) <- sample $ unProp $ property prop
               if ok r then putChar '.' >> loop (i+1)
                 else do printf "\nFalsified after %d tests!\n" i
                         callback t
    loop i = printf "\nOK, passed %d tests.\n" i

         
-- | traverse result tree looking for the minimal counterexample
--
shrinkSearch :: Tree Result -> IO Result
shrinkSearch (Node r ts) = loop maxShrinks r ts
  where
    loop :: Int -> Result -> [Tree Result] -> IO Result
    loop avail r ts
      | avail > 0 = 
          case dropWhile (ok.rootLabel) ts of
            [] -> putChar '\n' >> return r
            (t:_) -> do  putChar '.'
                         loop (avail-1) (rootLabel t) (subForest t)
    loop _ r _ = do printf "\nGave up after %d shrink steps!\n" maxShrinks
                    return r

-- | print the test case in a result
printTestCase :: Result -> IO ()
printTestCase = mapM_ putStrLn . testCase

